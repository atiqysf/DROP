import java.util.*;

public class DeliveryRouteOptimization {
    static int[][] distanceMatrix;
    static String[] locations;
    
    // Method to take user input for locations and distance matrix
    public static void getUserInput() {
        Scanner scanner = new Scanner(System.in);
        
        System.out.print("Enter the number of locations: ");
        int n = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        
        locations = new String[n];
        distanceMatrix = new int[n][n];
        
        System.out.println("Enter location names:");
        for (int i = 0; i < n; i++) {
            System.out.print("Location " + (i + 1) + ": ");
            locations[i] = scanner.nextLine();
        }
        
        System.out.println("Enter distance matrix:");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    distanceMatrix[i][j] = 0;
                } else {
                    System.out.print("Distance from " + locations[i] + " to " + locations[j] + ": ");
                    distanceMatrix[i][j] = scanner.nextInt();
                }
            }
        }
    }
    
    // Greedy TSP Implementation
    public static String greedyTSP(int[][] dist) {
        int n = dist.length;
        boolean[] visited = new boolean[n];
        StringBuilder path = new StringBuilder("Path: ");
        int totalCost = 0;
        int current = 0;
        visited[current] = true;
        path.append(locations[current]);
        
        for (int i = 1; i < n; i++) {
            int next = -1, minDist = Integer.MAX_VALUE;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && dist[current][j] < minDist) {
                    minDist = dist[current][j];
                    next = j;
                }
            }
            visited[next] = true;
            totalCost += minDist;
            path.append(" -> ").append(locations[next]);
            current = next;
        }
        totalCost += dist[current][0]; // Return to start
        path.append(" -> ").append(locations[0]);
        
        return path.toString() + "\nTotal Cost: " + totalCost;
    }
    
        // Dynamic Programming (Held-Karp) TSP Implementation
        public static int tspDP(int mask, int pos, int[][] dp, int[][] dist, int n) {
        if (mask == (1 << n) - 1) return dist[pos][0]; // Return to start
        if (dp[mask][pos] != -1) return dp[mask][pos];
    
        int minCost = Integer.MAX_VALUE;
        for (int city = 0; city < n; city++) {
            if ((mask & (1 << city)) == 0) { // If city is not visited
                int newCost = dist[pos][city] + tspDP(mask | (1 << city), city, dp, dist, n);
                minCost = Math.min(minCost, newCost);
            }
        }
        return dp[mask][pos] = minCost;
    }
    
    public static String dynamicProgrammingTSP(int[][] dist) {
        int n = dist.length;
        int[][] dp = new int[1 << n][n];
        for (int[] row : dp) Arrays.fill(row, -1);
        int cost = tspDP(1, 0, dp, dist, n);
        return "Optimal Cost (DP): " + cost;
    }

    
    // Backtracking TSP Implementation
    public static int tspBacktrack(int current, int visited, int[][] dp, int[][] dist, int n) {
        if (visited == (1 << n) - 1) return dist[current][0];
        if (dp[current][visited] != -1) return dp[current][visited];
        
        int minCost = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            if ((visited & (1 << i)) == 0) {
                int cost = dist[current][i] + tspBacktrack(i, visited | (1 << i), dp, dist, n);
                minCost = Math.min(minCost, cost);
            }
        }
        return dp[current][visited] = minCost;
    }
    
    public static String backtrackingTSP(int[][] dist) {
        int n = dist.length;
        int[][] dp = new int[n][1 << n];
        for (int[] row : dp) Arrays.fill(row, -1);
        int cost = tspBacktrack(0, 1, dp, dist, n);
        return "Optimal Cost (Backtracking): " + cost;
    }
    
    // Main method
    public static void main(String[] args) {
        getUserInput();
        System.out.println("\nGreedy Approach:");
        System.out.println(greedyTSP(distanceMatrix));
        System.out.println("\nDynamic Programming Approach:");
        System.out.println(dynamicProgrammingTSP(distanceMatrix));
        System.out.println("\nBacktracking Approach:");
        System.out.println(backtrackingTSP(distanceMatrix));
    }
}
